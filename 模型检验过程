i = 0
def mean_squared_error(p0):
    global i
    model_values = np.array(list(calculate_model_values(p0).values()))
    market_values = option_selection['PRICE'].values
    option_diffs = model_values - market_values
    MSE = np.sum(option_diffs ** 2) / len(option_diffs)
      # vectorized MSE calculation
    if i % 20 == 0:
        if i == 0:
            print('%4s  %6s  %6s  %6s --> %6s' % 
                 ('i', 'kappa', 'theta', 'vola', 'MSE'))
        print('%4d  %6.3f  %6.3f  %6.3f --> %6.3f' % 
                (i, p0[0], p0[1], p0[2], MSE))
    i += 1
    return MSE
mean_squared_error((0.5, 27.5, vol_est))
import scipy.optimize as spo
i = 0
opt_global = spo.brute(mean_squared_error,
                ((0.5, 3.01, 0.5),  # range for kappa
                 (15., 30.1, 5.),  # range for theta
                 (0.5, 5.51, 1)),  # range for volatility
                 finish=None)
i = 0
mean_squared_error(opt_global)
%%time
i = 0
opt_local = spo.fmin(mean_squared_error, opt_global,
                     xtol=0.00001, ftol=0.00001,
                     maxiter=100, maxfun=350)
i = 0
mean_squared_error(opt_local)
calculate_model_values(opt_local)
pd.options.mode.chained_assignment = None
option_selection['MODEL'] = \
        np.array(list(calculate_model_values(opt_local).values()))
option_selection['ERRORS'] = \
        option_selection['MODEL'] - option_selection['PRICE']
option_selection[['MODEL', 'PRICE', 'ERRORS']]
round(option_selection['ERRORS'].mean(), 3)
import matplotlib.pyplot as plt
%matplotlib inline
fix, (ax1, ax2) = plt.subplots(2, sharex=True, figsize=(10, 8))
strikes = option_selection['STRIKE'].values
ax1.plot(strikes, option_selection['PRICE'], label='market quotes')
ax1.plot(strikes, option_selection['MODEL'], 'ro', label='model values')
ax1.set_ylabel('option values')
ax1.grid(True)
ax1.legend(loc=0)
wi = 0.25
ax2.bar(strikes - wi / 2., option_selection['ERRORS'],
        label='market quotes', width=wi)
ax2.grid(True)
ax2.set_ylabel('differences')
ax2.set_xlabel('strikes');

 
